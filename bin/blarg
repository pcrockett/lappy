#!/usr/bin/env python3
import argparse
import hashlib
import json
import os
import re
import subprocess
import sys

from configparser import ConfigParser
from dataclasses import dataclass
from pathlib import Path
from shutil import rmtree
from tempfile import TemporaryDirectory
from typing import List, Optional


VERSION = "0.6.0"


STDLIB = """
#!/usr/bin/env bash

BLARG_TARGET_DEPENDENCIES=()

panic() {
    echo "FATAL: ${*}" >&2
    exit 1
}

log_verbose() {
    if [ "${BLARG_VERBOSE+x}" == "x" ]; then
        echo "${*}"
    fi
}

is_dry_run() {
    test "${BLARG_DRY_RUN+x}" == "x"
}

depends_on() {
    # this command may not be used in the user's target script, so we could get
    # a shellcheck "command unreachable" error here _sometimes_.
    #
    # shellcheck disable=SC2317
    BLARG_TARGET_DEPENDENCIES+=("$@")
}

is_external_module_target() {
    [[ "${1}" =~ ^@([a-zA-Z0-9_-]+):(.+)$ ]]
}

get_module_dir() {
    local script_basename="${1}" module_name module_env
    if is_external_module_target "${script_basename}"; then
        module_name="${BASH_REMATCH[1]}"
        module_env="BLARG_MODULE_${module_name}"
        echo "${!module_env}"
    else
        echo "${BLARG_MODULE_DIR}"
    fi
}

find_target() {
    local script_basename="${1}"
    local module_name module_env this_dir full_target_path search_dirs script_basename dir

    if is_external_module_target "${script_basename}"; then
        module_name="${BASH_REMATCH[1]}"
        script_basename="${BASH_REMATCH[2]}"
        module_env="BLARG_MODULE_${module_name}"
        if [ "${!module_env:-}" == "" ]; then
            search_dirs=()
        else
            search_dirs=("${!module_env}/targets")
        fi
    else
        this_dir="$(dirname "${BLARG_TARGET_PATH}")" || panic "unable to get directory name"
        search_dirs=(
            "${this_dir}"
            "${BLARG_TARGETS_DIR}"
        )
    fi

    for dir in "${search_dirs[@]}"; do
        full_target_path="${dir}/${script_basename}.bash"
        if [ -f "${full_target_path}" ]; then
            echo "${full_target_path}"
            return 0
        fi
    done
    return 1
}

satisfy() {
    local full_target_path script_basename module_dir target_result final_result

    final_result=0
    for script_basename in "$@"; do

        full_target_path="$(find_target "${script_basename}")" \\
            || panic "Target does not exist: ${script_basename}"

        module_dir="$(get_module_dir "${script_basename}")"
        BLARG_MODULE_DIR="${module_dir}" \\
            BLARG_TARGETS_DIR="${module_dir}/targets" \\
            "${full_target_path}"

        target_result=$?
        if [ ${target_result} -ne 0 ]; then
            if is_dry_run; then
                # `target_result` tells us that the target needs to run `apply`
                # we're going to keep iterating through dependencies, but ultimately
                # return 1.
                final_result=1
            else
                # `target_result` tells us that the target `apply` failed
                # it's time to bail.
                return ${target_result}
            fi
        fi
    done
    return ${final_result}
}
"""


BASE = """
satisfied_if() {
    # this command will normally be unreachable; the user's `satisfied_if`
    # implementation will very often override this one.
    #
    # shellcheck disable=SC2317
    false
}

"""


EXECUTOR = """
__BLARG_MAIN__() {
    local final_result=0
    if [ ${#BLARG_TARGET_DEPENDENCIES[@]} -gt 0 ]; then
        log_verbose "${BLARG_INDENT}${BLARG_TARGET_NAME} [dependencies...]"
        satisfy "${BLARG_TARGET_DEPENDENCIES[@]}"
        satisfy_result=$?
        if [ ${satisfy_result} -ne 0 ]; then
            if is_dry_run; then
                # `satisfy_result` tells us that a dependency needs an `apply`
                # we'll keep iterating through dependencies, but we know right now
                # that we'll be returning an exit code of 1.
                final_result=1
            else
                # `satisfy_result` tells us that a dependency's `apply` failed.
                # time to bail.
                return ${satisfy_result}
            fi
        fi
    fi

    log_verbose "${BLARG_INDENT}${BLARG_TARGET_NAME} [running...]"
    (
        set -Eeuo pipefail
        satisfied_if &> /dev/null
    )
    satisfied_if_result=$?

    if [ ${satisfied_if_result} -eq 0 ]; then
        log_verbose "${BLARG_INDENT}${BLARG_TARGET_NAME} [already satisfied]"
        return ${final_result}
    fi

    if is_dry_run; then
        if [ "$(type -t apply)" == "function" ]; then
            echo "dry-run: would apply ${BLARG_TARGET_NAME}"
            return 1
        else
            return ${final_result}
        fi
    elif [ "$(type -t apply)" == "function" ]; then
        (
            set -Eeuo pipefail
            apply
        )
        apply_result=$?
        test ${apply_result} -eq 0 || panic "${BLARG_TARGET_NAME}.apply() returned with code ${apply_result}."
    fi

    log_verbose "${BLARG_INDENT}${BLARG_TARGET_NAME} [done]"
    return ${final_result}
}

__BLARG_MAIN__
"""


@dataclass
class CliArgs:
    script_path: Optional[Path]
    dump_src: bool
    version: bool
    verbose: bool
    dry_run: bool


class CliParser(argparse.ArgumentParser):
    def __init__(self):
        super().__init__(
            "blarg",
            description="Execute bash target files <https://github.com/pcrockett/blarg>",
        )
        self.add_argument(
            "script_path", help="script file to execute", default=None, nargs="?"
        )
        self.add_argument(
            "--dump-src",
            "-d",
            help=(
                "output the full source that would be executed "
                "by Bash instead of running"
            ),
            action="store_true",
        )
        self.add_argument(
            "--version", help="display version number", action="store_true"
        )
        self.add_argument(
            "--verbose", "-v", help="display verbose output", action="store_true"
        )
        self.add_argument(
            "--dry-run", "-r", help="don't apply targets", action="store_true"
        )


def parse_args() -> CliArgs:
    args = CliParser().parse_args()
    return CliArgs(
        Path(args.script_path) if args.script_path else None,
        args.dump_src,
        args.version,
        args.verbose,
        args.dry_run,
    )


def list_dir_if_exists(dir_path: Path) -> List[Path]:
    try:
        return sorted([p.resolve() for p in dir_path.iterdir() if not p.is_dir()])
    except (FileNotFoundError, NotADirectoryError):
        return []


def generate_script(module_root_dir: Path, script_path: Path) -> str:
    script = f"# {script_path}\n" + script_path.read_text("utf8")
    script_parts = [STDLIB]

    lib_d_dir = module_root_dir / "lib.d"
    for file in list_dir_if_exists(lib_d_dir):
        if not str(file).endswith(".sh") and not str(file).endswith(".bash"):
            continue
        script_parts.append(f"# {file}\n{file.read_text('utf8')}\n")

    return "".join(script_parts + [BASE, script, EXECUTOR]).lstrip()


@dataclass
class ExternalModule:
    id: str
    location: str
    ref: str

    def init(self, working_dir: Path) -> Path:
        # `self.ref` could have some dangerous characters in it for file paths. let's
        # use an allowlist of known-safe characters, and replace everything else with
        # an underscore.
        #
        # if this ever gets ported to work on Windows, it needs to be adapted to account
        # for reserved file names as well.
        ALLOWED_REF_DIR_CHARS = set(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-0123456789"
        )
        sanitized_ref_chars: list[str] = []
        for ch in self.ref:
            if ch in ALLOWED_REF_DIR_CHARS:
                sanitized_ref_chars.append(ch)
            else:
                sanitized_ref_chars.append("_")
        ref_dir_name = "".join(sanitized_ref_chars)

        module_dir = working_dir / ".blarg" / "modules" / self.id / ref_dir_name

        if not (module_dir / ".git").exists():
            module_dir.mkdir(parents=True, exist_ok=True)
            source_dir = re.sub("^file://~", Path.home().as_uri(), self.location)

            try:
                subprocess.run(
                    [
                        "git",
                        "clone",
                        "--depth",
                        "1",
                        "--branch",
                        self.ref,
                        source_dir,
                        module_dir,
                    ],
                    check=True,
                )
            except:
                rmtree(module_dir)
                raise
        return module_dir


@dataclass
class BlargConfig:
    modules: List[ExternalModule]


def parse_config(config_path: Path) -> BlargConfig:
    ALLOWED_MODULE_NAME_CHARS = set("abcdefghijklmnopqrstuvwxyz_0123456789")
    config = ConfigParser()
    config.read(config_path)

    modules: List[ExternalModule] = []
    section: str
    for section in config.sections():
        (_, _, module_id) = section.partition("module.")
        if module_id == "":
            continue

        if len(set(module_id).difference(ALLOWED_MODULE_NAME_CHARS)) > 0:
            raise ValueError(
                f"Invalid module ID: `{module_id}`. Module IDs can only contain lowercase characters, underscores, and numbers."
            )

        modules.append(
            ExternalModule(
                module_id,
                config[section]["location"],
                config[section]["ref"],
            )
        )
    return BlargConfig(modules)


def main() -> int:
    args = parse_args()

    if args.version:
        print(f"blarg version {VERSION}")
        return 0

    if not args.script_path:
        CliParser().print_help()
        return 0

    script_path = args.script_path
    if script_path.is_dir():
        script_path = script_path / "main.bash"

    env = os.environ
    working_dir = Path(os.getcwd())

    if not env.get("BLARG_CWD"):
        env["BLARG_CWD"] = str(working_dir)

    module_dir_str = env.get("BLARG_MODULE_DIR")
    if module_dir_str is None:  # TODO: document difference between module dir and CWD
        module_dir = working_dir
        env["BLARG_MODULE_DIR"] = str(module_dir)
    else:
        module_dir = Path(module_dir_str)

    if args.dump_src:
        print(generate_script(module_dir, script_path))
        return 0

    config = parse_config(module_dir / "blarg.conf")
    for module in config.modules:
        module_dir = module.init(working_dir)
        env[f"BLARG_MODULE_{module.id}"] = str(module_dir)

    resolved_path = script_path.resolve()
    env["BLARG_TARGET_PATH"] = str(resolved_path)

    is_verbose = args.verbose or "BLARG_VERBOSE" in env
    if is_verbose:
        env["BLARG_VERBOSE"] = str(is_verbose)

    targets_dir = env.get("BLARG_TARGETS_DIR")
    if targets_dir:
        targets_dir = Path(targets_dir).resolve()
    else:
        targets_dir = str(Path.cwd() / "targets")
        env["BLARG_TARGETS_DIR"] = targets_dir

    dry_run = args.dry_run or "BLARG_DRY_RUN" in env
    if dry_run:
        env["BLARG_DRY_RUN"] = str(dry_run)

    indent = env.get("BLARG_INDENT")
    if indent is None:
        indent = "--> "
    else:
        indent = f" {indent}"
    env["BLARG_INDENT"] = indent

    target_name = str(resolved_path.with_suffix(""))
    _, _, shortened_target_name = target_name.partition(f"{targets_dir}/")
    env["BLARG_TARGET_NAME"] = shortened_target_name or target_name

    running_targets_unparsed = env.get("BLARG_RUNNING_TARGETS")
    if running_targets_unparsed:
        running_targets = json.loads(running_targets_unparsed)
    else:
        running_targets = []

    if str(resolved_path) in running_targets:
        stack_seperator = "\n-> "
        print(
            f"FATAL: Circular dependency detected at `{resolved_path}`:\n"
            f"{stack_seperator.join(running_targets)}"
            f"{stack_seperator}{resolved_path}",
            file=sys.stderr,
        )
        return 1

    running_targets.append(str(resolved_path))
    env["BLARG_RUNNING_TARGETS"] = json.dumps(running_targets)

    temp_dir_path = env.get("BLARG_RUN_DIR")
    if temp_dir_path:
        temp_dir = None  # a different blarg process is managing this directory
    else:
        temp_dir = TemporaryDirectory()
        temp_dir_path = temp_dir.name
        env["BLARG_RUN_DIR"] = temp_dir_path
        os.mkdir(f"{temp_dir_path}/.target-markers")

    script_path_digest = hashlib.sha1(str(resolved_path).encode("utf8")).hexdigest()
    marker_file = Path(temp_dir_path) / ".target-markers" / script_path_digest
    if marker_file.exists():
        return 0  # this target has already been run
    else:
        marker_file.touch()

    try:
        result = subprocess.run(
            ["bash", "-Euo", "pipefail"],
            input=generate_script(module_dir, script_path),
            encoding="utf8",
            env=env,
        )
    finally:
        if temp_dir is not None:
            temp_dir.cleanup()

    return result.returncode


if __name__ == "__main__":
    exit_code = main()
    quit(exit_code)
